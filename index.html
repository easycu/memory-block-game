<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ì•”ê¸° í¼ì¦ PRO v5.1</title>
    <style>
        :root { 
            --p: #3498db; --s: #2ecc71; --bg: #f0f2f5; 
            --preview: #e67e22; --danger: #e74c3c; --bonus: #f1c40f;
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0; padding: 0; user-select: none; }
        
        body { 
            font-family: -apple-system, 'Pretendard', sans-serif; 
            background: var(--bg);
            width: 100vw; height: 100dvh;
            display: flex; flex-direction: column; align-items: center; 
            overflow: hidden; touch-action: none; 
        }
        
        .screen { 
            display: none; width: 100%; max-width: 450px; 
            padding: env(safe-area-inset-top) 20px env(safe-area-inset-bottom) 20px; 
            height: 100%; flex-direction: column; 
        }
        .active { display: flex; }
        
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
        .shaking { animation: shake 0.5s; }

        .float-score {
            position: absolute; color: var(--bonus); font-weight: 900; font-size: 1.5rem;
            pointer-events: none; animation: floatUp 1s ease-out forwards; text-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 100;
        }
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(1.5); }
        }

        .header { 
            display: flex; justify-content: space-between; align-items: center; 
            padding: 10px 0; min-height: 70px; width: 100%;
        }
        
        #grid-container {
            flex: 1; display: flex; align-items: center; justify-content: center;
            width: 100%; min-height: 0; position: relative;
        }
        #grid { 
            display: grid; grid-template-columns: repeat(8, 1fr); gap: 4px; 
            background: #cbd5e0; padding: 6px; border-radius: 12px; 
            width: 100%; aspect-ratio: 1 / 1;
            transition: transform 0.1s;
        }
        .cell { background: #edf2f7; border-radius: 4px; aspect-ratio: 1 / 1; transition: all 0.2s; }
        .cell.filled { background: var(--p); transform: scale(0.95); }
        .cell.bonus-filled { background: var(--bonus); transform: scale(0.95); box-shadow: 0 0 10px rgba(241, 196, 15, 0.5); }
        .cell.clearing { background: var(--s); transform: scale(1.1); filter: brightness(1.2); }
        /* ê³ ìŠ¤íŠ¸ ë¸”ë¡ ìŠ¤íƒ€ì¼ (v5.1: ëª…í™•í•œ ê°€ì´ë“œ) */
        .cell.ghost { background: var(--p); opacity: 0.6; transform: scale(0.95); box-shadow: inset 0 0 0 3px rgba(255,255,255,0.7); }
        .cell.ghost-bonus { background: var(--bonus); opacity: 0.6; transform: scale(0.95); }

        #tray { 
            display: flex; justify-content: center; align-items: center; gap: 8px;
            height: 110px; margin-bottom: 15px; background: white; 
            border-radius: 20px; padding: 10px; width: 100%;
            touch-action: none; 
        }
        .shape-preview { width: 75px; height: 75px; display: grid; grid-template-columns: repeat(5, 1fr); gap: 1px; border-radius: 10px; padding: 4px; border: 2px solid transparent; background: #fdfdfd; transition: opacity 0.2s, visibility 0.2s; }
        .shape-preview.dragging { opacity: 0; visibility: hidden; } 
        .preview-cell { aspect-ratio: 1/1; }
        .preview-cell.filled { background: var(--p); border-radius: 1px; }
        .preview-cell.bonus { background: var(--bonus); border-radius: 1px; }

        /* ë“œë˜ê·¸ í—¬í¼ (ë”°ë¼ë‹¤ë‹ˆëŠ” ë¸”ë¡) */
        #drag-helper {
            position: fixed; pointer-events: none; z-index: 1000;
            display: none; 
            opacity: 0.9; 
            /* transform ì œê±°: JSì—ì„œ ì •ë°€ ê³„ì‚° */
        }
        #drag-helper .preview-cell { background: transparent; } 
        #drag-helper .preview-cell.filled, 
        #drag-helper .preview-cell.bonus { 
            box-shadow: 0 10px 20px rgba(0,0,0,0.25); border-radius: 4px;
        }

        .menu-btn { width: 100%; padding: 16px; margin: 8px 0; border: none; border-radius: 15px; color: white; font-size: 1.1rem; cursor: pointer; font-weight: bold; }
        .btn-game { background: var(--p); }
        .btn-manage { background: #9b59b6; }
        
        .word-list-container { flex: 1; overflow-y: auto; margin: 15px 0; width: 100%; }
        .word-card { background: white; padding: 15px; margin-bottom: 10px; border-radius: 12px; position: relative; border-left: 5px solid var(--p); box-shadow: 0 2px 5px rgba(0,0,0,0.05); }

        #quiz-modal { 
            position: fixed; top: 0; left: 0; width: 100vw; height: 100dvh; 
            background: rgba(0,0,0,0.9); display: none; 
            align-items: center; justify-content: center; z-index: 9999; padding: 20px; 
        }
        .modal-inner { 
            background: white; padding: 25px; border-radius: 25px; 
            width: 100%; max-width: 360px;
            display: flex; flex-direction: column; align-items: center;
        }
        #q-input { width: 100%; height: 100px; padding: 12px; border: 2px solid #e2e8f0; border-radius: 12px; font-size: 1rem; margin-bottom: 15px; resize: none; }
        #q-text { width: 100%; background: #f8fafc; padding: 15px; border-radius: 12px; margin-bottom: 15px; text-align: left; font-size: 0.95rem; line-height: 1.5; max-height: 150px; overflow-y: auto; }

        .file-ops { display: flex; flex-wrap: wrap; gap: 8px; width: 100%; margin-top: 10px; }
        .btn-outline { flex: 1; min-width: 45%; background: white; color: #666; border: 1px solid #ddd; padding: 10px; border-radius: 10px; font-size: 0.75rem; font-weight: bold; }
        .btn-append { background: #eef2ff; border-color: #c7d2fe; color: #4f46e5; }
    </style>
</head>
<body>
    <div id="drag-helper"></div>

    <div id="screen-home" class="screen active">
        <div style="flex:1; display:flex; flex-direction:column; justify-content:center; align-items:center;">
            <div style="font-size: 4.5rem; margin-bottom: 15px;">ğŸ§©</div>
            <h1 style="color: #2c3e50;">ì•”ê¸° í¼ì¦ PRO</h1>
            <div style="background:white; padding:10px 25px; border-radius:15px; margin: 20px 0; font-weight:bold; box-shadow:0 2px 8px rgba(0,0,0,0.05);">
                ìµœê³  ì ìˆ˜: <span id="high-score-home" style="color:var(--p)">0</span>
            </div>
        </div>
        <div class="home-btns">
            <button class="menu-btn btn-game" onclick="startGame()">ê²Œì„ ì‹œì‘</button>
            <button class="menu-btn btn-manage" onclick="showScreen('manage')">ë¬¸ì œ ê´€ë¦¬</button>
        </div>
    </div>

    <div id="screen-game" class="screen">
        <div class="header">
            <button onclick="confirmExit()" style="padding:8px 15px; border-radius:10px; border:none; background:#fff; font-weight:bold; box-shadow:0 2px 5px rgba(0,0,0,0.1); font-size: 0.9rem;">ğŸ  í™ˆ</button>
            <div class="score-box">
                <div style="font-size:0.7rem; color:#718096; font-weight: bold;">BEST <span id="high-score-game">0</span></div>
                <div style="font-weight:900; font-size:1.5rem; color:var(--p)" id="score">0</div>
            </div>
        </div>
        <div id="grid-container"><div id="grid"></div></div>
        <div id="tray"></div>
        <p style="font-size: 0.75rem; color: #94a3b8; text-align: center; margin-bottom: 10px;">ë¸”ë¡ì„ ë“œë˜ê·¸í•˜ì—¬ ì±„ìš°ì„¸ìš” (ì†ê°€ë½ ìœ„ì— í‘œì‹œë¨)</p>
    </div>

    <div id="screen-manage" class="screen">
        <h2 style="margin: 15px 0;">ë¬¸ì œ ê´€ë¦¬</h2>
        <div style="background:white; padding:15px; border-radius:15px; box-shadow:0 2px 10px rgba(0,0,0,0.05);">
            <textarea id="new-q" style="width:100%; height:80px; margin-bottom:10px; padding:10px; border:1px solid #ddd; border-radius:8px; resize:none;" placeholder="ë¬¸ì œë¥¼ ì…ë ¥í•˜ì„¸ìš”"></textarea>
            <textarea id="new-a" style="width:100%; height:60px; margin-bottom:10px; padding:10px; border:1px solid #ddd; border-radius:8px; resize:none;" placeholder="ì •ë‹µì„ ì…ë ¥í•˜ì„¸ìš” (O/X ë˜ëŠ” ì£¼ê´€ì‹)"></textarea>
            <button onclick="addWord()" class="menu-btn btn-game" style="margin:0; padding: 12px;">í•œ ê°œ ì¶”ê°€</button>
            <div class="file-ops">
                <button class="btn-outline" onclick="exportJSON()">ë‚´ë³´ë‚´ê¸°</button>
                <button class="btn-outline" onclick="triggerFile('import')">ë®ì–´ì“°ê¸°</button>
                <button class="btn-outline btn-append" onclick="triggerFile('append')">ë°ì´í„° í•©ì¹˜ê¸°</button>
            </div>
            <input type="file" id="file-input" style="display:none" onchange="handleFile(event)" accept=".json">
        </div>
        <div class="word-list-container" id="word-list"></div>
        <button class="menu-btn" style="background:#64748b; margin-top: auto;" onclick="showScreen('home')">ëŒì•„ê°€ê¸°</button>
    </div>

    <div id="quiz-modal">
        <div class="modal-inner">
            <h2 id="q-title" style="color:var(--p); margin-bottom:15px;">ë³µìŠµ íƒ€ì„!</h2>
            <div id="q-text"></div>
            <textarea id="q-input" placeholder="ì •ë‹µì„ ì…ë ¥í•˜ì„¸ìš”"></textarea>
            <div id="q-feedback" style="margin-bottom:15px; font-weight:bold; font-size: 0.9rem; text-align: center;"></div>
            <button id="q-submit" class="menu-btn btn-game" onclick="checkQuizAnswer()" style="margin:0; padding: 12px;">í™•ì¸</button>
            <button id="q-next" class="menu-btn btn-manage" style="display:none; margin:0; padding: 12px;" onclick="nextQuestion()">ë‹¤ìŒ ë¬¸ì œ</button>
        </div>
    </div>

<script>
    // --- ì˜¤ë””ì˜¤ ì‹œìŠ¤í…œ ---
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    let audioContext = null;

    function initAudio() {
        if (!audioContext) audioContext = new AudioCtx();
        if (audioContext.state === 'suspended') audioContext.resume();
    }

    const soundTypes = {
        click: (t) => {
            const osc = audioContext.createOscillator(); const gain = audioContext.createGain();
            osc.frequency.setValueAtTime(600, t); osc.frequency.exponentialRampToValueAtTime(300, t + 0.1);
            gain.gain.setValueAtTime(0.1, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
            osc.connect(gain); gain.connect(audioContext.destination); osc.start(t); osc.stop(t + 0.1);
        },
        place: (t) => {
            const osc = audioContext.createOscillator(); const gain = audioContext.createGain();
            osc.frequency.setValueAtTime(200, t); osc.frequency.exponentialRampToValueAtTime(50, t + 0.1);
            gain.gain.setValueAtTime(0.2, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
            osc.type = 'triangle'; osc.connect(gain); gain.connect(audioContext.destination); osc.start(t); osc.stop(t + 0.15);
        },
        clear: (t) => {
            const notes = [523.25, 659.25, 783.99, 1046.50];
            notes.forEach((freq, i) => {
                const osc = audioContext.createOscillator(); const gain = audioContext.createGain();
                osc.frequency.value = freq; const time = t + i * 0.05;
                gain.gain.setValueAtTime(0.1, time); gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);
                osc.connect(gain); gain.connect(audioContext.destination); osc.start(time); osc.stop(time + 0.3);
            });
        },
        correct: (t) => {
            [523.25, 659.25, 783.99].forEach((f,i) => {
                const osc = audioContext.createOscillator(); const gain = audioContext.createGain();
                osc.frequency.value = f; osc.type = 'sine';
                gain.gain.setValueAtTime(0.1, t + i*0.1); gain.gain.linearRampToValueAtTime(0, t + i*0.1 + 0.4);
                osc.connect(gain); gain.connect(audioContext.destination); osc.start(t + i*0.1); osc.stop(t + i*0.1 + 0.4);
            });
        },
        wrong: (t) => {
            const osc = audioContext.createOscillator(); const gain = audioContext.createGain();
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(150, t); osc.frequency.linearRampToValueAtTime(100, t + 0.3);
            gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t + 0.3);
            osc.connect(gain); gain.connect(audioContext.destination); osc.start(t); osc.stop(t + 0.3);
        }
    };
    function playSound(type) { if(audioContext) soundTypes[type](audioContext.currentTime); }

    // --- ê²Œì„ ê¸°ë³¸ ë³€ìˆ˜ ---
    const GRID_SIZE = 8;
    const TOTAL_CELLS = 64;
    const SHAPES = [
        [[0,0],[0,1],[1,0],[1,1]], [[0,0],[1,0],[2,0],[3,0],[4,0]], [[0,0],[0,1],[0,2],[0,3],[0,4]],
        [[0,0],[1,0],[2,0]], [[0,0],[0,1],[0,2]], [[0,0],[1,0],[2,0],[2,1],[2,2]],
        [[0,0],[0,1],[0,2],[1,2],[2,2]], [[0,0],[1,1],[2,2],[3,3]], [[0,2],[1,2],[2,0],[2,1],[2,2]],
        [[0,1],[1,0],[1,1],[1,2],[2,1]], [[0,0],[0,1],[1,1],[1,2],[2,2]], [[0,0],[1,0],[1,1]],
        [[0,0],[0,1],[1,0]], [[0,0],[0,1],[0,2],[0,3]], [[0,0],[1,0],[2,0],[3,0]], [[0,0]]
    ];
    
    let score = 0, highScore = localStorage.getItem('puzzleBest8x8') || 0;
    let grid = Array(TOTAL_CELLS).fill(0), trayShapes = [];
    let vocabulary = JSON.parse(localStorage.getItem('myVocab')) || [{q:"ì•”ê¸° í¼ì¦ ì‹œì‘!", a:"O", wrongCount: 0}];
    let fileMode = 'import';

    // --- ë“œë˜ê·¸ ì•¤ ë“œë¡­ ë³€ìˆ˜ ---
    let isDragging = false;
    let dragShapeIndex = null;
    let ghostIndices = []; 
    // v5.1 ìˆ˜ì •: ì‹œì•¼ í™•ë³´ë¥¼ ìœ„í•œ 75px ê°„ê²© (ì†ê°€ë½ ê°€ë¦¼ ë°©ì§€)
    const TOUCH_OFFSET = 75; 
    let anchorRow = 0; // ë“œë˜ê·¸ ì¤‘ì¸ ë¸”ë¡ì˜ 'ì¡ëŠ” ê¸°ì¤€' í–‰
    let anchorCol = 0; // ë“œë˜ê·¸ ì¤‘ì¸ ë¸”ë¡ì˜ 'ì¡ëŠ” ê¸°ì¤€' ì—´

    function showScreen(id) {
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        document.getElementById('screen-' + id).classList.add('active');
        window.scrollTo(0, 0); updateScores();
        if(id === 'manage') renderWordList();
    }
    function updateScores() {
        document.getElementById('high-score-home').innerText = highScore;
        document.getElementById('high-score-game').innerText = highScore;
        document.getElementById('score').innerText = score;
    }

    // --- í€´ì¦ˆ ë¡œì§ ---
    function startQuiz() {
        if(vocabulary.length < 1) { refillTray(0); return; }
        curQuiz = 0; quizCorrect = 0;
        let allWords = [...vocabulary];
        for (let i = allWords.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [allWords[i], allWords[j]] = [allWords[j], allWords[i]];
        }
        let wrongWords = allWords.filter(v => v.wrongCount > 0);
        let finalSelection = [];
        if(wrongWords.length > 0) {
            finalSelection.push(wrongWords[0]);
            allWords = allWords.filter(v => v !== wrongWords[0]);
        }
        while(finalSelection.length < 3 && allWords.length > 0) {
            finalSelection.push(allWords.shift());
        }
        sessionQuizzes = finalSelection;
        document.getElementById('quiz-modal').style.display = 'flex';
        showQuestion();
    }
    function showQuestion() {
        const q = sessionQuizzes[curQuiz];
        document.getElementById('q-title').innerText = `ê²€í†  (${curQuiz + 1}/3)`;
        document.getElementById('q-text').innerText = q.q;
        document.getElementById('q-input').value = "";
        document.getElementById('q-feedback').innerText = "";
        document.getElementById('q-submit').style.display = "block";
        document.getElementById('q-next').style.display = "none";
    }
    function checkQuizAnswer() {
        const rawInput = document.getElementById('q-input').value.trim();
        const inputNoSpace = rawInput.replace(/\s/g, "").toUpperCase(); 
        const originalAns = sessionQuizzes[curQuiz].a;
        const actualAnsNoSpace = originalAns.replace(/\s/g, "").toUpperCase(); 
        const feedbackEl = document.getElementById('q-feedback');
        let isCorrect = false;
        
        if (inputNoSpace === "O" || inputNoSpace === "X") {
            if (actualAnsNoSpace.charAt(0) === inputNoSpace) isCorrect = true;
        } 
        if (!isCorrect && inputNoSpace === actualAnsNoSpace) isCorrect = true;

        if (isCorrect) {
            quizCorrect++; playSound('correct');
            if(sessionQuizzes[curQuiz].wrongCount > 0) sessionQuizzes[curQuiz].wrongCount--;
            feedbackEl.innerHTML = `<span style='color:var(--s)'>ì •ë‹µ! âœ¨<br>ì •ë‹µ: ${originalAns}</span>`;
        } else {
            playSound('wrong');
            sessionQuizzes[curQuiz].wrongCount = (sessionQuizzes[curQuiz].wrongCount || 0) + 1;
            feedbackEl.innerHTML = `<span style='color:var(--danger)'>ì˜¤ë‹µ! âŒ<br>ì •ë‹µ: ${originalAns}</span>`;
        }
        localStorage.setItem('myVocab', JSON.stringify(vocabulary)); 
        document.getElementById('q-submit').style.display = "none";
        document.getElementById('q-next').style.display = "block";
    }
    function nextQuestion() {
        curQuiz++;
        if (curQuiz < 3) showQuestion();
        else {
            document.getElementById('quiz-modal').style.display = 'none';
            if (quizCorrect >= 2) refillTray(quizCorrect);
            else { alert("ë¶ˆí•©ê²©! 2ë¬¸ì œ ì´ìƒ ë§ì¶°ì•¼ í•©ë‹ˆë‹¤."); startQuiz(); }
        }
    }
    function refillTray(correctCount) {
        trayShapes = [0,1,2].map(() => [...SHAPES[Math.floor(Math.random()*SHAPES.length)]]);
        if(correctCount === 3) {
            const bonus = [[0,0]]; bonus.isBonus = true;
            trayShapes.push(bonus);
        }
        renderTray();
        checkGameOver();
    }

    // --- ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì‹œìŠ¤í…œ v5.1 (í•€í¬ì¸íŠ¸ ì •ë ¬ ì—”ì§„) ---
    function renderTray() {
        const trayEl = document.getElementById('tray');
        trayEl.innerHTML = "";
        trayShapes.forEach((s, i) => {
            if(s === null) return;
            const div = document.createElement('div');
            div.className = 'shape-preview';
            
            div.addEventListener('touchstart', (e) => handleTouchStart(e, i), {passive: false});
            div.addEventListener('touchmove', (e) => handleTouchMove(e), {passive: false});
            div.addEventListener('touchend', (e) => handleTouchEnd(e), {passive: false});
            div.addEventListener('mousedown', (e) => handleTouchStart(e, i));

            for(let r=0; r<5; r++) for(let c=0; c<5; c++) {
                const cell = document.createElement('div');
                const isPart = s.some(p=>p[0]===r&&p[1]===c);
                cell.className = isPart ? (s.isBonus ? 'preview-cell filled bonus' : 'preview-cell filled') : 'preview-cell';
                div.appendChild(cell);
            }
            trayEl.appendChild(div);
        });
    }

    function handleTouchStart(e, idx) {
        if(e.cancelable) e.preventDefault();
        isDragging = true;
        dragShapeIndex = idx;
        const s = trayShapes[idx];

        const helper = document.getElementById('drag-helper');
        helper.innerHTML = "";
        
        const cellRect = document.querySelector('.cell').getBoundingClientRect();
        const cellSize = cellRect.width;

        // v5.1: í•€í¬ì¸íŠ¸ ì•µì»¤ ê³„ì‚° (ë¸”ë¡ì˜ 'ë§¨ ì•„ë˜' & 'ì¤‘ì•™' ì¹¸ ì°¾ê¸°)
        let minR=5, maxR=-1, minC=5, maxC=-1;
        s.forEach(p => {
            minR = Math.min(minR, p[0]); maxR = Math.max(maxR, p[0]);
            minC = Math.min(minC, p[1]); maxC = Math.max(maxC, p[1]);
        });
        
        // ì•µì»¤ í¬ì¸íŠ¸: ëª¨ì–‘ì˜ ë°”ë‹¥í–‰(maxR) + ìˆ˜í‰ì¤‘ì•™ì—´(ë°˜ì˜¬ë¦¼)
        // ì´ 'íŠ¹ì • ì¹¸'ì´ ì†ê°€ë½ ìœ„(OFFSET ì§€ì )ì— ì˜¤ê²Œ ë¨
        anchorR = maxR;
        anchorC = Math.round((minC + maxC) / 2);

        const rows = maxR - minR + 1;
        const cols = maxC - minC + 1;

        helper.style.display = "grid"; 
        helper.style.gridTemplateRows = `repeat(${rows}, ${cellSize}px)`;
        helper.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;
        helper.style.gap = "1px";
        helper.style.width = (cols * cellSize + (cols-1)) + 'px';
        helper.style.height = (rows * cellSize + (rows-1)) + 'px';

        for(let r=minR; r<=maxR; r++) {
            for(let c=minC; c<=maxC; c++) {
                const cell = document.createElement('div');
                const isPart = s.some(p=>p[0]===r&&p[1]===c);
                cell.className = isPart ? (s.isBonus ? 'preview-cell filled bonus' : 'preview-cell filled') : 'preview-cell';
                if (!isPart) cell.style.visibility = "hidden";
                helper.appendChild(cell);
            }
        }
        
        moveHelper(e);
        e.currentTarget.classList.add('dragging');
        playSound('click');
    }

    function handleTouchMove(e) {
        if(!isDragging) return;
        if(e.cancelable) e.preventDefault();
        moveHelper(e);
        updateGhost(e);
    }

    function handleTouchEnd(e) {
        if(!isDragging) return;
        isDragging = false;
        document.getElementById('drag-helper').style.display = "none"; 
        document.querySelectorAll('.shape-preview').forEach(el => el.classList.remove('dragging'));

        if(ghostIndices.length > 0) {
            placeBlock(ghostIndices, trayShapes[dragShapeIndex]);
        } else {
            clearGhost();
        }
        ghostIndices = [];
        dragShapeIndex = null;
    }

    function moveHelper(e) {
        const helper = document.getElementById('drag-helper');
        const cx = e.touches ? e.touches[0].clientX : e.clientX;
        const cy = e.touches ? e.touches[0].clientY : e.clientY;
        
        const cellRect = document.querySelector('.cell').getBoundingClientRect();
        const cellSize = cellRect.width;
        const s = trayShapes[dragShapeIndex];
        
        // í—¬í¼ì˜ ë°”ìš´ë”© ë°•ìŠ¤ ê³„ì‚° (ë‹¤ì‹œ í•„ìš”í•¨)
        let minR=5, maxR=-1, minC=5, maxC=-1;
        s.forEach(p => {
            minR = Math.min(minR, p[0]); maxR = Math.max(maxR, p[0]);
            minC = Math.min(minC, p[1]); maxC = Math.max(maxC, p[1]);
        });

        // v5.1 ì •ë°€ ë³´ì •:
        // ì•µì»¤ ì¹¸ì˜ ì¤‘ì‹¬ì´ (cx, cy - offset)ì— ì˜¤ë„ë¡ Helperì˜ left/top ê³„ì‚°
        // ì•µì»¤ ì¹¸ì€ Helper ë‚´ë¶€ì—ì„œ (anchorR - minR, anchorC - minC) ìœ„ì¹˜ì— ìˆìŒ
        
        const relAnchorR = anchorR - minR;
        const relAnchorC = anchorC - minC;
        
        // (cx, cy - offset) = helperLeft + (relAnchorC * size + size/2), helperTop + (relAnchorR * size + size/2)
        const targetX = cx;
        const targetY = cy - TOUCH_OFFSET;
        
        const helperLeft = targetX - (relAnchorC * cellSize + cellSize / 2);
        const helperTop = targetY - (relAnchorR * cellSize + cellSize / 2);

        helper.style.left = helperLeft + 'px';
        helper.style.top = helperTop + 'px'; 
    }

    function updateGhost(e) {
        const cx = e.touches ? e.touches[0].clientX : e.clientX;
        const cy = e.touches ? e.touches[0].clientY : e.clientY;
        
        // íƒì§€ ì§€ì ë„ ì •í™•íˆ (cx, cy - offset)
        const targetY = cy - TOUCH_OFFSET; 

        const helper = document.getElementById('drag-helper');
        helper.style.display = 'none'; 
        const el = document.elementFromPoint(cx, targetY);
        helper.style.display = 'grid';

        clearGhost();

        if(!el || !el.classList.contains('cell')) return;

        // íƒ€ê²Ÿ ì…€ = ìš°ë¦¬ê°€ ì¡ê³  ìˆëŠ” 'ì•µì»¤ ì¹¸'ì´ ë†“ì¼ ê³³
        const targetIdx = parseInt(el.id.split('-')[1]);
        const tR = Math.floor(targetIdx / 8);
        const tC = targetIdx % 8;
        const s = trayShapes[dragShapeIndex];

        // ë°°ì¹˜ ì›ì (0,0) ê³„ì‚°: íƒ€ê²Ÿ ì…€ì—ì„œ ì•µì»¤ ì¹¸ì˜ ìƒëŒ€ ì¢Œí‘œë¥¼ ëºŒ
        const shiftR = tR - anchorR;
        const shiftC = tC - anchorC;
        
        let indices = [];
        const fit = s.every(p => {
            const nr = p[0] + shiftR;
            const nc = p[1] + shiftC;
            
            if(nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && grid[nr*8 + nc] === 0) {
                indices.push(nr*8 + nc);
                return true;
            }
            return false;
        });

        if(fit) {
            ghostIndices = indices;
            indices.forEach(idx => {
                const cell = document.getElementById('cell-' + idx);
                cell.classList.add(s.isBonus ? 'ghost-bonus' : 'ghost');
            });
        }
    }

    function clearGhost() {
        document.querySelectorAll('.cell').forEach(c => {
            c.classList.remove('ghost');
            c.classList.remove('ghost-bonus');
        });
    }

    function placeBlock(indices, s) {
        playSound('place');
        indices.forEach(idx => {
            grid[idx] = 1;
            const cell = document.getElementById('cell-' + idx);
            cell.className = s.isBonus ? 'cell bonus-filled' : 'cell filled';
        });
        
        trayShapes[dragShapeIndex] = null;
        renderTray();
        checkLines();

        if(trayShapes.every(v => v === null)) startQuiz();
        else checkGameOver();
    }

    // --- ê²Œì„ íš¨ê³¼ ë° ìœ í‹¸ë¦¬í‹° ---
    function triggerShake() {
        const g = document.getElementById('grid');
        g.classList.remove('shaking'); void g.offsetWidth; g.classList.add('shaking');
    }
    function showFloatingScore(txt) {
        const el = document.createElement('div'); el.className = 'float-score'; el.innerText = `+${txt}`;
        const rect = document.getElementById('grid').getBoundingClientRect();
        el.style.left = (rect.width / 2 - 20) + "px"; el.style.top = (rect.height / 2 - 20) + "px";
        document.getElementById('grid-container').appendChild(el); setTimeout(() => el.remove(), 1000);
    }
    function checkLines() {
        let rs=[], cs=[];
        for(let i=0; i<8; i++) {
            if(grid.slice(i*8, i*8+8).every(v=>v===1)) rs.push(i);
            let col=[]; for(let j=0; j<8; j++) col.push(grid[j*8+i]);
            if(col.every(v=>v===1)) cs.push(i);
        }
        const count = rs.length + cs.length;
        if(count > 0) {
            playSound('clear'); triggerShake();
            let gained = count * 10 * count; score += gained;
            showFloatingScore(gained);
            if(score > highScore) { highScore=score; localStorage.setItem('puzzleBest8x8', highScore); }
            updateScores();
        }
        rs.forEach(r => { for(let c=0; c<8; c++) animateClear(r*8+c); });
        cs.forEach(c => { for(let r=0; r<8; r++) animateClear(r*8+c); });
    }
    function animateClear(i) { 
        grid[i]=0; const el=document.getElementById('cell-'+i); 
        el.classList.add('clearing'); setTimeout(()=>{ el.className = 'cell'; }, 300); 
    }
    function checkGameOver() {
        const canPlaceAny = trayShapes.some(s => {
            if(!s) return false;
            for(let i=0; i<64; i++) {
                const r=Math.floor(i/8), c=i%8;
                const fit = s.every(p => {
                    const nr=r+p[0], nc=c+p[1];
                    return nr<8 && nc<8 && grid[nr*8+nc] === 0;
                });
                if(fit) return true;
            }
            return false;
        });
        if(!canPlaceAny && !trayShapes.every(v => v === null)) {
            alert("ê²Œì„ ì¢…ë£Œ! ìµœì¢… ì ìˆ˜: " + score); showScreen('home');
        }
    }
    function startGame() { initAudio(); if(vocabulary.length < 1) return alert("ë¬¸ì œë¥¼ ë“±ë¡í•´ì£¼ì„¸ìš”."); showScreen('game'); initGame(); }
    function initGame() {
        score = 0; grid.fill(0); updateScores();
        const gridEl = document.getElementById('grid'); gridEl.innerHTML = "";
        for (let i = 0; i < TOTAL_CELLS; i++) {
            const cell = document.createElement('div');
            cell.className = 'cell'; cell.id = 'cell-' + i;
            gridEl.appendChild(cell);
        }
        refillTray(0);
    }
    
    // ë¬¸ì œ ê´€ë¦¬ ë¡œì§ (ê¸°ì¡´ ìœ ì§€)
    function isDuplicate(q, a) {
        const nQ = q.replace(/\s/g, "").toUpperCase(); const nA = a.replace(/\s/g, "").toUpperCase();
        return vocabulary.some(item => item.q.replace(/\s/g, "").toUpperCase() === nQ && item.a.replace(/\s/g, "").toUpperCase() === nA);
    }
    function addWord() {
        const q=document.getElementById('new-q').value.trim(), a=document.getElementById('new-a').value.trim();
        if(q&&a) { 
            if(isDuplicate(q, a)) return alert("ì¤‘ë³µëœ ë¬¸ì œì…ë‹ˆë‹¤!");
            vocabulary.push({q, a, wrongCount: 0}); localStorage.setItem('myVocab', JSON.stringify(vocabulary)); 
            renderWordList(); document.getElementById('new-q').value=""; document.getElementById('new-a').value=""; 
        }
    }
    function renderWordList() {
        document.getElementById('word-list').innerHTML = vocabulary.map((v, i) => `
            <div class="word-card"><b>${v.q}</b><br><small>ì •ë‹µ: ${v.a}</small>
            ${v.wrongCount > 0 ? `<span style="color:var(--danger); font-size:0.7rem; font-weight:bold;"><br>ğŸ”¥ ë³µìŠµ í•„ìš” (${v.wrongCount})</span>` : ''}
            <button onclick="deleteWord(${i})" style="position:absolute;right:10px;top:10px;border:none;background:none;font-size:1.2rem;color:#ccc;">âœ•</button></div>
        `).reverse().join(''); 
    }
    function deleteWord(i) { if(confirm("ì‚­ì œí• ê¹Œìš”?")) { vocabulary.splice(i,1); localStorage.setItem('myVocab',JSON.stringify(vocabulary)); renderWordList(); } }
    function triggerFile(mode) { fileMode = mode; document.getElementById('file-input').click(); }
    function handleFile(e) {
        const file = e.target.files[0]; if(!file) return;
        const reader = new FileReader();
        reader.onload = (evt) => {
            try {
                const newData = JSON.parse(evt.target.result);
                if (fileMode === 'append') {
                    let dup = 0; let add = 0;
                    newData.forEach(item => { if(isDuplicate(item.q, item.a)) dup++; else { vocabulary.push({...item, wrongCount:item.wrongCount||0}); add++; } });
                    alert(`ì¤‘ë³µ ${dup}ê°œ ì œì™¸, ${add}ê°œ ì¶”ê°€ ì™„ë£Œ!`);
                } else { vocabulary = newData.map(v => ({...v, wrongCount: v.wrongCount || 0})); alert("ëª©ë¡ êµì²´ ì™„ë£Œ!"); }
                localStorage.setItem('myVocab', JSON.stringify(vocabulary)); renderWordList();
            } catch (err) { alert("í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤."); }
            e.target.value = '';
        };
        reader.readAsText(file);
    }
    function exportJSON() {
        const blob = new Blob([JSON.stringify(vocabulary, null, 2)], {type: "application/json"});
        const a = document.createElement("a"); a.href = URL.createObjectURL(blob); a.download = `quiz_backup.json`; a.click();
    }
    function confirmExit() { if(confirm("í™ˆìœ¼ë¡œ ë‚˜ê°ˆê¹Œìš”?")) showScreen('home'); }
    window.onload = updateScores;
    // PC ë“œë˜ê·¸ ì§€ì›
    window.addEventListener('mousemove', (e) => { if(isDragging) { moveHelper(e); updateGhost(e); } });
    window.addEventListener('mouseup', (e) => { if(isDragging) handleTouchEnd(e); });
</script>
</body>
</html>
